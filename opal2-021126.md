Project Title: FDA 510(k) Agentic Reviewer v3.0 â€“ "The Enterprise Futurist"
1. System Identity & Role Definition
Role: You are an Expert Full-Stack Software Architect, UI/UX Designer specialized in "Future-Tech" interfaces, and a Senior Regulatory Affairs Engineer.
Objective: Create a complete, functional, and visually stunning Single Page Application (SPA) called the FDA 510(k) Agentic Reviewer v3.0.
Framework: React v19.2.4 (using Vite or similar modern bundler structure).
Language: TypeScript (Strict Mode).
Styling: Tailwind CSS v3.x with a custom "Glassmorphism/Neomorphism" engine.
Core AI Engine: Google GenAI SDK (@google/genai) connecting to Gemini 2.5 Flash and Gemini 3.0.
2. Executive Summary & Core Philosophy
The application is a client-side, serverless tool designed to ingest unstructured text from FDA 510(k) medical device submissions and use Agentic AI workflows to parse, analyze, and audit the data.
The UI must embody an "Enterprise Futurist" aesthetic. It should feel like a tool used in a high-tech sci-fi command center (think Minority Report meets Clinical Sterile). It must feature translucent glass panels, neon accent glows, and fluid animations that signify "thinking" states.
2.1 The "Agentic" Shift
Unlike a passive viewer, this app must be Agentic. It does not just display text; it:
Extracts structure from chaos.
Identifies gaps proactively.
Audits against specific regulations (21 CFR Part 820/ISO 14971).
Self-Corrects (via the new Self-Healing JSON feature).
3. Detailed Architecture Specification
3.1 Project Structure
Generate the application with the following file structure principles. Ensure logical separation of concerns.
code
Text
/src
  /assets        (SVGs, static images)
  /components
    /common      (Buttons, GlassCard, Badge, LoadingSpinner, Modal)
    /layout      (Sidebar, Header, MainLayout)
    /visuals     (GradientBackground, ParticleEffects)
  /context       (AppContext, ThemeContext)
  /features
    /dashboard   (MissionControl, ProgressWidgets)
    /orchestrator(IngestionZone, FileParser)
    /strategy    (GapAnalysis, RiskTable)
    /compliance  (AuditLog, Checklist)
    /auditor     (ChatInterface, MessageBubble)
    /vision      (LabelingInspector - NEW FEATURE)
  /hooks         (useThemeRandomizer, useGemini, useTypewriter)
  /lib           (gemini.ts, zodSchemas.ts, constants.ts, utils.ts)
  /styles        (index.css with CSS variables)
  App.tsx
  main.tsx
3.2 State Management (The "Brain")
Implement a monolithic AppContext using useReducer. This is the Single Source of Truth (SSOT).
State Interface:
code
TypeScript
interface AppState {
  apiKey: string | null;
  selectedModel: "gemini-2.5-flash" | "gemini-3.0-flash-preview";
  theme: ThemePalette;
  // Submission Data
  rawText: string | null;
  parsedData: ParsedSubmissionData | null;
  // Analysis States
  summary: SummaryContent | null;
  gapAnalysis: GapAnalysis | null;
  riskAssessment: RiskAssessment | null;
  complianceReport: ComplianceReport | null;
  // New AI Feature States
  labelingAnalysis: LabelingComplianceReport | null; // Feature 1
  predicateVerification: PredicateCheck | null;      // Feature 2
  // Chat & Logs
  chatHistory: ChatMessage[];
  auditLog: AuditLogEntry[];
  // UI States
  isLoading: boolean;
  loadingStage: string; // e.g., "Scanning predicates...", "Calculating risk..."
  error: string | null;
}
4. UI/UX Design System: "Glass & Neon"
4.1 Theming Engine (useThemeRandomizer)
You must implement a dynamic CSS variable system. Do not hardcode colors in Tailwind classes. Instead, map Tailwind config to CSS variables.
Themes to Implement:
Cyber Med: Background #0f172a, Surface rgba(30, 41, 59, 0.7), Primary #06b6d4 (Cyan Neon), Accent #f472b6 (Pink).
Clinical Glass: Background #f8fafc, Surface rgba(255, 255, 255, 0.6), Primary #0ea5e9 (Sky Blue), Text #334155.
Bio-Synthetic: Background #022c22, Surface rgba(6, 78, 59, 0.6), Primary #34d399 (Emerald), Accent #a78bfa.
Sterile White: High-key, monochromatic slate/gray with subtle blue interactions.
Visual Requirements:
Glass Cards: backdrop-filter: blur(16px); border: 1px solid var(--glass-border); box-shadow: 0 8px 32px var(--glass-shadow);
Typography: Inter or JetBrains Mono (for data).
Animations: Use framer-motion or CSS keyframes for animate-gradient-x (background movement) and pulse-glow (AI active state).
5. Functional Modules & AI Features
5.1 The Orchestrator (Ingestion)
UI: A large, dashed-border drop zone.
Logic: Use FileReader to read .txt, .json, or .md files.
AI Action: When text is loaded, automatically trigger the Parsing Agent.
Prompt Strategy: "Extract the Device Name, Manufacturer, Indication for Use, and Technology Principles from this text. Output strict JSON."
Validation: Verify against ParsedSubmissionDataSchema (defined in Section 7).
5.2 Dashboard ("Mission Control")
Visuals: A grid of widget cards.
Widgets:
Stage Tracker: A progress bar showing % complete (Parsing -> Summary -> Risk -> Compliance).
Equivalence Score: A speedometer gauge (0-100%).
Active Device: Large typography displaying the extracted device name.
5.3 Strategic Analysis (The "Agent")
This section contains tabs for "Gap Analysis" and "Risk Profiling".
Gap Analysis: Compare Subject Device vs Predicate Device.
Table: Columns for Feature, Subject, Predicate, Determination (Equivalent/Different), and Impact.
Risk Profiling (ISO 14971):
Logic: Ask Gemini to "Simulate a Preliminary Hazard Analysis based on the Indications for Use."
Output: A table of Hazard, Sequence of Events, Harm, and Mitigation.
5.4 Smart Auditor (RAG Chat)
Context: Inject parsedData into the system prompt of every message.
Persona: "You are an expert FDA Auditor. You are skeptical but fair. Cite evidence."
UI: Chat bubble interface. User bubbles (Primary Color), AI bubbles (Glass).
6. Three Additional AI Features (Innovation Layer)
Based on advanced requirements, incorporate these three specific AI features into the architecture.
Feature 1: Labeling Vision Guard (Multi-Modal)
Concept: FDA 510(k)s require reviewing physical labels for specific symbols (Rx Only, Sterile, etc.).
Implementation:
Create a new route /labeling.
Allow image upload (drag & drop).
AI Service: Use gemini-pro-vision.
Prompt: "Analyze this medical device label image. Identify: 1. Presence of 'Rx Only'. 2. Sterility symbols. 3. Manufacturer address. 4. Font readability issues. Return JSON."
UI: Display the uploaded image on the left, and a "Compliance Overlay" or checklist on the right.
Feature 2: Predicate Verifier Agent (Hallucination Grounding)
Concept: LLMs often hallucinate predicate device details. This agent acts as a "Fact Checker."
Implementation:
Inside the Gap Analysis module, add a "Verify Predicate" button.
Logic: Trigger a specific prompt: "You are a regulatory historian. Does the device '[Predicate Name]' exist in the FDA 510(k) database history? What is its likely 510(k) number (K-number)? Rate your confidence 0-100%."
Note: Since we don't have real FDA API access in this client-side demo, the AI simulates this check based on its training data.
UI: A badge appears next to the Predicate Name: "Verified (Confidence: 98%)" or "Flagged: Unknown Device".
Feature 3: Self-Healing JSON Weaver (Robustness)
Concept: LLMs sometimes output broken JSON (missing brackets, trailing commas) which crashes the app.
Implementation:
Wrap the gemini.ts response handler in a try/catch block.
The "Weaver" Loop: If JSON.parse or Zod.parse fails, catch the error.
Recursive Call: Send a new prompt to Gemini: "You generated invalid JSON. Here is the error: [Error Log]. Here is the malformed string: [Bad JSON]. Fix the syntax and return ONLY the raw JSON."
Retry: Attempt to parse the repair. If it fails twice, throw a user error.
7. Data Schemas (Zod)
You must use Zod for all AI outputs. Define these schemas in lib/zodSchemas.ts.
code
TypeScript
import { z } from "zod";

// Core Parsing Schema
export const ParsedSubmissionDataSchema = z.object({
  deviceName: z.string(),
  manufacturer: z.string(),
  kNumber: z.string().optional(),
  indicationsForUse: z.string(),
  deviceDescription: z.string(),
  technologyPrinciples: z.string(),
  predicateDeviceName: z.string(),
  sterilizationMethod: z.string().optional(),
});

// Strategic Gap Analysis
export const GapAnalysisSchema = z.object({
  equivalenceScore: z.number().min(0).max(100),
  overallConclusion: z.string(),
  features: z.array(z.object({
    featureName: z.string(),
    subjectDevice: z.string(),
    predicateDevice: z.string(),
    comparison: z.enum(["EQUIVALENT", "DIFFERENT", "UNKNOWN"]),
    safetyImpact: z.string(),
  })),
});

// ISO 14971 Risk
export const RiskAssessmentSchema = z.object({
  hazards: z.array(z.object({
    hazardType: z.string(), // e.g., "Electrical", "Biological"
    sequenceOfEvents: z.string(),
    harm: z.string(),
    initialRiskLevel: z.enum(["Low", "Medium", "High"]),
    mitigationControl: z.string(),
  })),
});

// Feature 1: Labeling Vision
export const LabelingSchema = z.object({
  rxSymbolPresent: z.boolean(),
  sterileSymbolPresent: z.boolean(),
  manufacturerAddressVisible: z.boolean(),
  warningsFound: z.array(z.string()),
  complianceStatus: z.enum(["PASS", "FAIL", "REQUIRES_REVIEW"]),
});
8. Implementation Guide & Code Snippets
8.1 The AI Service Layer (lib/geminiService.ts)
Write a robust service that handles the "Self-Healing" logic.
code
TypeScript
// Pseudo-code implementation requirement
import { GoogleGenerativeAI } from "@google/genai";
import { ParsedSubmissionDataSchema } from "./zodSchemas";

export const generateStructuredData = async (
  prompt: string, 
  schema: any, 
  apiKey: string,
  modelName: string = "gemini-2.5-flash",
  retryCount: number = 0
) => {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ 
    model: modelName,
    generationConfig: { responseMimeType: "application/json" } 
  });

  try {
    const result = await model.generateContent(prompt);
    const text = result.response.text();
    const json = JSON.parse(text);
    return schema.parse(json); // Zod Validation
  } catch (error) {
    if (retryCount < 2) {
      console.warn("JSON Malformed, triggering Self-Healing Weaver...");
      const repairPrompt = `System: You previously output invalid JSON. Fix this error: ${error}. 
      Malformed Output: ${text}. 
      Return ONLY valid JSON matching the schema.`;
      return generateStructuredData(repairPrompt, schema, apiKey, modelName, retryCount + 1);
    }
    throw error;
  }
};
8.2 The "WOW" Sidebar Component
Create a generic Sidebar that uses the glass effect. It should contain the API Key input (masked) and the Theme Toggler.
8.3 The Glass Layout Wrapper
Ensure the App.tsx wraps everything in a div that applies the background gradient and handles the CSS variables injection.
9. Security & Compliance Requirements (Instructional)
Zero Backend: Explicitly state in the code comments that no data is sent to any server other than Google's API directly from the client.
API Key Safety: Provide a mechanism to use sessionStorage for the API key so it is lost on tab close (for security on shared devices).
Audit Trail: Every time the AI generates a response, dispatch an action to ADD_AUDIT_LOG with a timestamp and the operation name.
10. Final Output Instructions
Please generate the complete React code for this application.
Start with lib/constants.ts and lib/zodSchemas.ts to define the data shape.
Create the lib/geminiService.ts including the Self-Healing Weaver.
Create the context/AppContext.tsx handling the complex state.
Build the UI components starting with the Layout and ThemeEngine.
Implement the Features: Orchestrator, Dashboard, Strategic Analysis, and the Labeling Vision Guard.
Ensure the styling uses Tailwind classes that reference the CSS variables defined in your global CSS.
Tone of Voice for the UI: Professional, encouraging, and highly technical. Use tooltips to explain AI confidence scores.
Go.
End of Prompt
Additional Context for the AI Studio (Hidden Metadata)
The following notes are for the generative engine to understand specific constraints:
Optimization: Focus on code modularity. The App.tsx should be clean, relying on feature components.
Animations: Use framer-motion syntax for transitions if possible, otherwise standard CSS transitions.
Icons: Use lucide-react or heroicons.
Detailed Follow-Up Feature Breakdown (Integrated into the Prompt above)
To ensure the "3 Additional AI Features" are perfectly clear in the generated code, here is the logic you (the AI) must apply when generating the code for Section 6 of the prompt:
Logic for Feature 1: Labeling Vision Guard
The generated code must include a file features/vision/LabelingInspector.tsx.
State: Needs to store an imagePreviewUrl.
Conversion: Must convert the File object to Base64 to send to Gemini Vision.
Rendering: Draw bounding boxes (simulated or real if coordinates provided) or simply list the findings in a "Red/Green" checklist.
Logic for Feature 2: Predicate Verifier
The generated code must modify features/strategy/GapAnalysis.tsx.
Interaction: The user shouldn't have to trigger this manually; it should happen automatically after the Gap Analysis is complete.
Visual Cue: Use a small "Badge" component.
Green Check: "FDA Database Match"
Yellow Warning: "Unverified in Training Data"
Logic for Feature 3: Self-Healing Weaver
This is a purely functional infrastructure change.
Location: lib/geminiService.ts.
Refactor: The standard generateContent call must be wrapped. The recursive retry logic is crucial. This makes the app "Agentic" because it detects its own failure and attempts to fix it without user intervention.
Summary of Word Count & Depth
This prompt provides approximately 2000+ words of detailed instruction (when combined with the code boilerplate requests and architectural definitions). It covers:
Visual Language: "Enterprise Futurist", Glassmorphism.
Tech Stack: React 19, Tailwind, Zod, Gemini SDK.
Business Logic: FDA 510(k) specific workflows (Gap Analysis, Risk, Compliance).
Novelty: Self-healing code, Vision analysis, and Fact-checking agents.
This prompt is ready for immediate execution in a code generation studio.
